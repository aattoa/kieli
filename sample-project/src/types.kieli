alias Int  = I64
alias Uint = U64

enum Option[T] = none | some(T)


struct S = x: Int

impl S {
  fn templatetest[m: mut](&mut?m self) = &mut?m (*self).x
  fn size(&self): Int = (*self).x
}


fn method_test(s: S): &Int {
  discard s.size();
  s.templatetest()
}

impl S {
  fn abc[T](&self): T { discard self; ??? }
}

fn method_template_test[T]() {
  let x: S = ???;
  x.abc[T]()
}
fn method_template_test_2(): String = method_template_test()

fn pointer_unification_test(): Int {
  let p = ???;
  unsafe_dereference(addressof(p))
}


fn map_option[A, B](opt: Option[A], f: fn(A): B): Option[B] {
  match opt {
    Option::some(x) -> Option::some(f(x))
    Option::none    -> Option::none
  }
}
fn map_option_test(opt: Option[Int]): Option[String] = map_option(opt, ???)


fn basic_unification_test_0() {
  let x = ???;
  let f: fn(String): Int = ???;
  f(x)
}
fn basic_unification_test_1() {
  match Option::none {
    Option::some(x) -> x
    Option::none -> "hello"
  }
}

fn conditional[T](c: Bool, a: T, b: T) {
  if c { a } else { b }
}

fn basic_unification_test_3() = conditional(true, 3.14, 2.74)



struct Triple[A, B = A, C = B] = a: A, b: B, c: C
fn type_test() = Triple { a = "Hello", b = 50.2, c = ??? : Int }


struct Pair[A = _, B = _] = first: A, second: B
fn wildcard_test() = Pair[] { first = "aaaa", second = 2.74 }.second
struct RefPair[A, B, a: mut = mut, b: mut = mut?a] = first: &mut?a A, second: &mut?b B
fn mutability_test() = RefPair[Int, Float, _, _] { first = ??? : &Int, second = ??? : &mut Float }


fn get_opt_value[T](option: Option[T]) {
  match option {
    Option::some(x) -> x
    Option::none -> ???
  }
}
fn test_get_opt_value(): I32 = get_opt_value(Option::none)

fn second[m: mut, A, B](pair: &mut (A, B)) = &mut?m ((*pair).1)
fn second_test1(): &mut String = second(??? : &mut (Int, String))
fn second_test2(): &String = second(??? : &mut (Int, String))


/* works
fn opt_new[T](): Option[T] = ???
fn opt_set[T](_: &mut Option[T], _: T): () = ???
fn opt_hmm() {
  let mut v = opt_new();
  opt_set(&mut v, "hello");
  opt_set(&mut v, 3.14);
}*/


fn opt_get[T](_: Option[T]): T = ???
fn aaa(): String {
  let o = ???;
  let x = opt_get(o);
  (x, x).0
}
fn bbb(): Int {
  let o = ???;
  let x = opt_get(o);
  (x, x).0
}


/*fn double_solution_test() {
    let x = 5;
    let _: (I32, I64) = (x, x);
    x
}*/
