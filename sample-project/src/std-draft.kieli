class Functor F[_] {
  fn map[A, B](F[A], fn(A): B): F[B]
}
class Monad M[_] {
  fn bind[A, B](M[A], fn(A): M[B]): M[B]
}

enum Option[T] = some(T) | none

inst Monad for Option {
  fn bind(o, f) = match o {
    Option::some(x) -> f(x)
    Option::none    -> Option::none
  }
}
inst Functor for Option {
  fn map(o, f) = o.bind(\x -> Option::some(f))
}

impl[T] Option[T] {
  fn value_or(self, default: T): T {
    match self {
      Option::some(x) -> x
      Option::none    -> default
    }
  }
}



//  _*2
//  (*2)
//  |x|x*2
//  \x.x*2
//  \x->x*2
//  lambda x:x*2
//  [](auto x){return x*2;}



fn main(): Int = Option::some(5).map(\x->x*2).value_or(0)
